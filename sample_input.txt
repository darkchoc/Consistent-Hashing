Sample Input 1:

PRINT
100
1
Default
ADD NODE nodeone
ADD NODE nodetwo
ADD DATA 1
ADD DATA 2
ADD DATA 3
ADD DATA 13
PRINT
ADD NODE nodethree
PRINT
ADD DATA 4
ADD DATA 22
PRINT
ADD NODE nodefour
ADD NODE nodefive
ADD DATA 14
ADD DATA 20
PRINT
REMOVE DATA 20
REMOVE DATA 14
PRINT
REMOVE NODE nodethree
PRINT
REMOVE NODE nodefive
REMOVE NODE nodeone
PRINT
REMOVE NODE nodetwo
PRINT


Sample Input 2 ():
100
1
Default
ADD NODE nodetwo
ADD DATA 1
ADD DATA 2
ADD DATA 3
ADD DATA 13
ADD DATA 22
PRINT
ADD NODE nodethree


Sample Input 3 (Testing case when deletion in 2 nodes and datapoint's hash = node's hash):
100
1
Default
ADD NODE nodeone
ADD DATA 1
ADD NODE nodetwo
PRINT
REMOVE NODE nodeone
PRINT

Sample Input 4:
100
3
Default
ADD NODE nodeone
ADD DATA 1
ADD DATA 3
PRINT
ADD NODE nodethree
PRINT


Sample Input 5:
100
3
Default
ADD NODE nodeone
ADD DATA 1
ADD DATA 3
ADD NODE nodethree
PRINT
ADD DATA 2
ADD DATA 4
ADD DATA 5
ADD DATA 6
ADD DATA 7
ADD DATA 8
ADD DATA 9
ADD DATA 10
ADD DATA 11
ADD DATA 12
ADD DATA 13
PRINT
ADD NODE nodefive
PRINT
REMOVE NODE nodefive
ADD NODE nodefour
PRINT
REMOVE NODE nodeone
PRINT



Sample Input 6: (Testing segmentation fault while removing node which had a collision while adding. Got corrected by
adding a check whether a particular hashKey exists in table or not. We might have removed a node earlier, which 
was causing collision while adding this second node, so when we are deleting this second node, we have to check whether
hashKey exists in table or not, otherwise doing just hashTable[hashKey]==node will insert a node in hashTable for key =
hashKey and node=NULL)
100
3
Default
ADD NODE nodeone
ADD NODE nodethree
ADD NODE nodefour
REMOVE NODE nodeone
REMOVE NODE nodefour
